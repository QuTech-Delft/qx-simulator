{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>QX simulator is a simulator of cQASM programs, developed by QuTech. At the moment, QX simulator only supports cQASM v3.0 programs (see cQASM-spec for the language specification).</p> <p>It performs simulations of input programs received via file or string. It produces one of the following results:</p> <ul> <li>A simulation result: a quantum state and, optionally, a list of measurements.</li> <li>An error. In case of an invalid input program or failed simulation.</li> </ul> <p>It can be used as:</p> <ul> <li>A standalone executable (built from C++), from the command line.</li> <li>A module (called <code>qxelarator</code>), from Python projects (as a Python package).</li> </ul>"},{"location":"index.html#cqasm-v30-specification-coverage","title":"cQASM v3.0 specification coverage","text":"<p>QX simulator has the following shortcomings regarding to the current cQASM v3.0 specification:</p> <ul> <li>Power gate modifier can only be used with integer exponents, not with fractional (rational or irrational) ones.</li> </ul>"},{"location":"about/authors.html","title":"Authors","text":"<p>QX simulator is developed as part of the Quantum Inspire project: support@quantum-inspire.com</p>"},{"location":"about/contributing.html","title":"Contributing","text":"<p>Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are greatly appreciated.</p> <p>If you have a suggestion that would make this better, please fork the repo and create a pull request.</p> <ol> <li>Fork the project.</li> <li>Create your feature branch (<code>git checkout -b feature/AmazingFeature</code>).</li> <li>Commit your changes (<code>git commit -m 'Add some AmazingFeature'</code>).</li> <li>Push to the branch (<code>git push origin feature/AmazingFeature</code>).</li> <li>Open a pull request.</li> </ol>"},{"location":"about/license.html","title":"License","text":"<p>QX simulator is licensed under the Apache License, Version 2.0. See LICENSE for the full license text.</p>"},{"location":"about/release-notes.html","title":"Release Notes","text":"<p>Coming soon</p>"},{"location":"api/cpp-api.html","title":"C++","text":"<p>QX simulator allows simulating a cQASM program via two APIs: <code>execute_string</code> and <code>execute_file</code>.</p> <p>These functions are implemented in C++ code, and thus visible through a C++ header file: <code>include/qx/qxelarator.hpp</code>.</p> <pre><code>std::variant&lt;std::monostate, qx::SimulationResult, qx::SimulationError&gt; execute_string(const std::string&amp; program, std::size_t iterations, std::optional&lt;std::uint_fast64_t&gt; seed, std::string version);</code></pre> <p>Simulates a cQASM program from a string.</p> <p>Parameters:<ul> <li><p><code>program</code> is a string containing the cQASM program.</p> </li><li><p><code>iterations</code> is the number of times the program is being simulated.</p> </li><li><p><code>seed</code> can be used in case a deterministic output is needed.</p> </li><li><p><code>version</code> is the cQASM program version.</p> </li></ul> </p> <p>Returns either a simulation result or an error. </p> <pre><code>std::variant&lt;std::monostate, qx::SimulationResult, qx::SimulationError&gt; execute_file(const std::string&amp; file_path, std::size_t iterations, std::optional&lt;std::uint_fast64_t&gt; seed, std::string version);</code></pre> <p>Simulates a cQASM program from a file.</p> <p>Parameters:<ul> <li><p><code>file_path</code> is the file path of the cQASM program.</p> </li><li><p><code>iterations</code> is the number of times the program is being simulated.</p> </li><li><p><code>seed</code> can be used in case a deterministic output is needed.</p> </li><li><p><code>version</code> is the cQASM program version.</p> </li></ul> </p> <p>Returns either a simulation result or an error. </p>"},{"location":"api/python-api.html","title":"Python","text":"<p><code>execute_string</code> and <code>execute_file</code> return either a <code>SimulationResult</code> or a <code>SimulationError</code>.</p> <p>These are actually Python classes that work as bindings for accessing C++ code from Python. They are defined in <code>python/qxelarator/__init__.py</code>.</p> <pre><code>class SimulationResult</code></pre> <p>A simulation result object. </p> <pre><code>shots_requested: </code></pre> <p>Number of iterations the simulation was requested to be performed. </p> <pre><code>shots_done: </code></pre> <p>Number of iterations the simulation was actually performed. </p> <pre><code>results: </code></pre> <p>Contains the number of times a given measurement value is captured when running the iterations. </p> <pre><code>state: </code></pre> <p>Contains the full quantum state at the end of the very last iteration. </p> <pre><code>class SimulationError</code></pre> <p>A simulation error object, containing just an error message. </p> <pre><code>message: </code></pre> <p>Error message. </p>"},{"location":"dev-guide/cpp-dev-guide.html","title":"C++","text":"<p>You can build the C++ binaries from the project's root directory.</p> <pre><code>conan build . -pr:a=conan/profiles/tests-debug -b missing\n</code></pre> <p>You can test the C++ binaries:</p> <pre><code>cd build/Debug\nctest -C Debug --output-on-failure\n</code></pre>"},{"location":"dev-guide/dev-guide.html","title":"Dev Guide","text":""},{"location":"dev-guide/dev-guide.html#file-organization","title":"File organization","text":"<p>For development, see:</p> <ul> <li><code>include/qx</code>: public headers.</li> <li><code>src/qx</code>: source files.</li> <li><code>src/qx-simulator</code>: command line executable entry point.</li> <li><code>test</code>: test files.</li> <li><code>python</code>: SWIG interface.</li> </ul> <p>For build process, continuous integration, and documentation:</p> <ul> <li><code>conan</code>: Conan profiles.</li> <li><code>scripts</code>: helper scripts used during the build process.</li> <li><code>.github</code>: GitHub Actions configuration files.</li> <li><code>doc</code>: documentation.</li> </ul> <p>Build outputs may go into:</p> <ul> <li><code>build/&lt;build type&gt;</code>: the C++ library output files generated by Conan.</li> <li><code>pybuild</code>: the Python library output files generated by <code>setup.py</code>.</li> </ul>"},{"location":"dev-guide/dev-guide.html#dependencies","title":"Dependencies","text":"<ul> <li>C++ compiler with C++23 support (gcc 11, clang 14, msvc 17)</li> <li><code>CMake</code> &gt;= 3.12</li> <li><code>git</code></li> <li><code>Python</code> 3.x plus <code>pip</code>, with the following package:<ul> <li><code>conan</code> &gt;= 2.0</li> </ul> </li> <li><code>SWIG</code></li> </ul>"},{"location":"dev-guide/dev-guide.html#arm-builds","title":"ARM builds","text":"<p>We are having problems when using the <code>zulu-openjdk</code> Conan package on an ARMv8 architecture. <code>zulu-openjdk</code> provides the Java JRE required by the ANTLR generator. For the time being, we install Java manually for this platform.</p> <ul> <li><code>Java JRE</code> &gt;= 11</li> </ul>"},{"location":"dev-guide/dev-guide.html#documentation","title":"Documentation","text":"<ul> <li><code>doxygen</code></li> <li><code>mkdocs</code> with the following packages:<ul> <li><code>mike</code></li> <li><code>mkdocs-material</code></li> <li><code>mkdocstrings</code></li> <li><code>pymdown-extensions</code></li> </ul> </li> </ul>"},{"location":"dev-guide/dev-guide.html#linters","title":"Linters","text":"<ul> <li><code>clang-format-18</code></li> <li><code>clang-tidy-18</code></li> </ul> <p>On a Linux machine, these linters can be installed with the following commands:</p> <pre><code>wget https://apt.llvm.org/llvm.sh -O llvm_install.sh\nchmod +x llvm_install.sh\n./llvm_install.sh\napt-get install -y clang-format-18 clang-tidy-18\n</code></pre>"},{"location":"dev-guide/dev-guide.html#build","title":"Build","text":"<p>This version of QX simulator can only be compiled via the Conan package manager. You will need to create a default profile before using it for the first time.</p> <p>The installation of dependencies, as well as the compilation, can be done in one go.</p> <pre><code>git clone https://github.com/QuTech-Delft/qx-simulator.git\ncd qx-simulator\nconan profile detect\nconan build . -pr:a=conan/profiles/tests-debug -b missing\n</code></pre> <p>Note</p> <ul> <li>the <code>conan profile</code> command has to be run only once, and not before every build.</li> <li>the <code>conan build</code> command is building QX simulator in Debug mode with tests using the <code>tests-debug</code> profile.</li> <li>the <code>-b missing</code> parameter asks <code>conan</code> to build packages from sources   in case it cannot find the binary packages for the current configuration (platform, OS, compiler, build type...).</li> </ul>"},{"location":"dev-guide/dev-guide.html#profiles","title":"Profiles","text":"<p>A group of predefined profiles is provided under the <code>conan/profiles</code> folder. They follow the <code>[tests-](build_type)(-compiler)(-os)(-arch)</code> naming convention:</p> <ul> <li><code>tests</code>: if tests are being built.</li> <li><code>build_type</code>: can be <code>debug</code> or <code>release</code>.</li> <li><code>compiler</code>: <code>apple-clang</code>, <code>clang</code>, <code>gcc</code>, <code>msvc</code>.</li> <li><code>os</code>: <code>linux</code>, <code>macos</code>, <code>windows</code>.</li> <li><code>arch</code>: <code>arm64</code>, <code>x64</code>.</li> </ul> <p>All the profiles set the C++ standard to 23. Address Sanitizer is currently disabled for all profiles.</p>"},{"location":"dev-guide/dev-guide.html#options","title":"Options","text":"<p>Profiles are a shorthand for command line options. The command above could be written, similarly, as:</p> <pre><code>conan build . -s:a compiler.cppstd=23 -s:a qx/*:build_type=Debug -c tools.build:skip_test=False -b missing\n</code></pre> <p>This is the list of options that could be specified either in a profile or in the command line:</p> <ul> <li><code>qx/*:asan_enabled={True,False}</code>: enables Address Sanitizer.</li> <li><code>qx/*:build_type={Debug,Release}</code>: builds in Debug or Release mode.</li> </ul> <p>Tests are disabled by default. To enable them, use <code>-c tools.build:skip_test=False</code>.</p>"},{"location":"dev-guide/dev-guide.html#documentation_1","title":"Documentation","text":"<p>Build and serve on <code>http://127.0.0.1:8000/</code>.</p> <pre><code>export PYTHONPATH=./scripts/python\nmkdocs serve\n</code></pre> <p>Note</p> <p>The <code>export</code> is needed to point <code>mkdocs</code> to the custom handlers used for the C++ and Python APIs.</p>"},{"location":"dev-guide/dev-guide.html#linters_1","title":"Linters","text":"<p>Continuous Integration will fail if the files do not adhere to a series of formatting and code style guidelines:</p> <ul> <li>Formatting checks are defined in <code>.clang-format</code>.</li> <li>Code style checks are defined in <code>.clang-tidy</code>.</li> </ul> <p>It is recommended to run these linters before pushing any changes:</p> <pre><code>conan build . -pr:a=conan/profiles/tests-release-gcc-linux-x64 -b missing\npython3 ./scripts/run_cpp_linters.py .\n</code></pre> <p>Note</p> <ul> <li>The linters require <code>clang-format-18</code> and <code>clang-tidy-18</code>. </li> <li>It is mandatory to have a build before running the linters.<ul> <li><code>clang-tidy</code> expects to find a <code>compile_commands.json</code> in a build folder.</li> </ul> </li> <li>It is recommended to build with <code>gcc</code> in Release mode.<ul> <li>We have observed <code>clang-tidy</code> fails to find some standard headers when compiling with <code>clang</code>.</li> <li><code>run_cpp_linters.py</code> can receive a build folder as second argument, but defaults to <code>build/Release</code>.</li> </ul> </li> </ul>"},{"location":"dev-guide/dev-guide.html#simulator-internals","title":"Simulator internals","text":""},{"location":"dev-guide/dev-guide.html#sparse-state-vector","title":"Sparse state vector","text":"<p>QX simulator internally represents a quantum state using a hash table mapping kets (e.g., <code>|0010110&gt;</code>) to their associated complex amplitudes, and omits zero (or near-zero) amplitudes.</p> <p>You can read about this approach in this paper by Samuel Jaques and Thomas H\u00e4ner. Note however that QX simulator was developed independently and the internal implementation differs.</p> <p>Representing a quantum state in this way is, in many cases, very beneficial in terms of simulation runtime and memory usage.</p>"},{"location":"dev-guide/dev-guide.html#error-models","title":"Error models","text":"<p>Error models allow the introduction of probabilistic errors during the execution of the quantum circuit. They are useful for simulating more realistically a real quantum computer.</p> <p>The only supported error model is currently the depolarizing channel. This model is implemented as described in Quantum Computation and Quantum Information by Nielsen &amp; Chuang. Note that the book uses the density matrix/quantum computation formalism, while QX simulator only uses state vector simulation.</p> <p>The model is parametrized by a probability of error p. Between each gate of the circuit, an error on a uniformly randomly chosen qubit is applied with probability p. The error is uniformly an X (bit-flip), Y, or Z (phase-flip) gate.</p> <p>Warning</p> <p>The current cQASM 3.0 language specification does not allow for the specification of an error model. Thus, while the QX simulator offers support for working with an error model, this feature cannot be exercised.</p>"},{"location":"dev-guide/python-dev-guide.html","title":"Python","text":"<p>You can build and install the Python package from the project's root directory.</p> <pre><code>python3 -m pip install --verbose .\n</code></pre> <p>You can test the Python package:</p> <pre><code>python3 -m pytest\n</code></pre>"},{"location":"user-guide/command-line.html","title":"Command Line","text":"<p>QX simulator can be executed from the command line.</p> <pre><code>build/Release$ ./qx-simulator -c 1000 ../../test/qxelarator/bell_pair.cq\n</code></pre> <p>In the example above:</p> <ul> <li><code>qx-simulator</code> is the name of the executable.</li> <li><code>-c</code> can be used, optionally, to indicate a number of iterations (<code>1000</code> in this case).</li> <li><code>../test/qxelarator/bell_pair.cq</code> is the path to the file containing the cQASM program. </li> </ul>"},{"location":"user-guide/python-user-guide.html","title":"Python","text":"<p>QX simulator can be installed as a Python package:</p> <pre><code>pip install qxelarator\n</code></pre> <p>And then imported from a Python program.</p>"},{"location":"user-guide/python-user-guide.html#how-to-run-the-simulator","title":"How to run the simulator","text":""},{"location":"user-guide/python-user-guide.html#execute_string","title":"execute_string","text":"<p>The simplest way to simulate a cQASM program is using the <code>execute_string</code> method:</p> <pre><code>&gt;&gt;&gt; import qxelarator\n\n&gt;&gt;&gt; result = qxelarator.execute_string(\"version 3.0; qubit[2] q; H q[0]\")\n\n&gt;&gt;&gt; result\nShots requested: 1\nShots done: 1\nMeasurements: {'00': 1}\nState: {'00': (0.7071067811865475+0j), '01': (0.7071067811865475+0j)}\n</code></pre>"},{"location":"user-guide/python-user-guide.html#execute_file","title":"execute_file","text":"<p>The cQASM program can also be retrieved from a file:</p> <pre><code>&gt;&gt;&gt; qxelarator.execute_file(\"bell_pair.cq\")\nShots requested: 1\nShots done: 1\nMeasurements: {'11': 1}\nState: {'11': (1+0j)}\n</code></pre>"},{"location":"user-guide/python-user-guide.html#simulation-output","title":"Simulation output","text":""},{"location":"user-guide/python-user-guide.html#simulationresult","title":"SimulationResult","text":"<p>If the simulation succeeds, it will return a <code>SimulationResult</code> object, which offers access to: - the final quantum state, and  - the aggregated measurement register.</p> <pre><code>&gt;&gt;&gt; isinstance(result, qxelarator.SimulationResult)\nTrue\n\n&gt;&gt;&gt; result.state[\"00\"]\n(0.7071067811865475+0j)\n\n&gt;&gt;&gt; result.measurements\n{'00': 1}\n</code></pre>"},{"location":"user-guide/python-user-guide.html#simulationerror","title":"SimulationError","text":"<p>In case the simulation fails, a <code>qxelarator.SimulationError</code> object is returned:</p> <pre><code>&gt;&gt;&gt; r = qxelarator.execute_string(\"version 3.0; qubit[2] q; H q[0\")\n&gt;&gt;&gt; r\nQuantum simulation error: cQASM v3 analyzer returned errors:\nError at &lt;unknown file name&gt;:1:31: missing ']' at '&lt;EOF&gt;'\n\n&gt;&gt;&gt; isinstance(r, qxelarator.SimulationError)\nTrue\n</code></pre>"},{"location":"user-guide/python-user-guide.html#simulation-parameters","title":"Simulation parameters","text":""},{"location":"user-guide/python-user-guide.html#iterations","title":"Iterations","text":"<p>To simulate a quantum circuit multiple times, a number of <code>iterations</code> can be specified:</p> <pre><code>&gt;&gt;&gt; qxelarator.execute_file(\"bell_pair.cq\", iterations=10)\nShots requested: 10\nShots done: 10\nMeasurements: {'00': 3, '11': 7}\nState: {'11': (1+0j)}\n</code></pre>"},{"location":"user-guide/python-user-guide.html#seed","title":"Seed","text":"<p>By default, QX simulator will generate different random numbers for different executions of a given circuit. This means that <code>measure</code>, <code>reset</code>, and error models will make simulation results non-deterministic.</p> <p>In some cases this is not desired. To make the output of the simulator deterministic over different runs, you can pass a constant <code>seed</code> parameter:</p> <pre><code>qxelarator.execute_string(\"version 3.0; qubit[2] q; bit[2] b; H q[0]; b = measure q\", iterations=1000, seed=123)\n</code></pre>"},{"location":"user-guide/user-guide.html","title":"User Guide","text":"<p>QX simulator can be used as:</p> <ul> <li>A standalone executable (built from C++), from the command line.</li> <li>A module (called <code>qxelarator</code>), from Python projects (as a Python package).</li> </ul>"},{"location":"user-guide/user-guide.html#output","title":"Output","text":"<p>The results of a simulation will be dumped to standard output, when running the standalone executable, or to a <code>SimulationResult</code> object, when using the Python API.</p> <p>Let's simulate a Bell pair 100 times:</p> <pre><code>version 3.0\nqubit[2] q\n\nH q[0] \nCNOT q[0], q[1]\n</code></pre> <p>The output of the simulation should be:</p> <pre><code>Shots requested: 100\nShots done: 100\nMeasurements: {'00': 100}\nState: {'00': (0.7071067811865475+0j), '11': (0.7071067811865475+0j)}\n</code></pre> <ul> <li><code>Shots requested</code> and <code>Shots done</code> are always equal to the number of iterations.</li> <li><code>Measurements</code> contains the number of times a given measurement value is captured when running the iterations.   In this case, the circuit does not contain any measurements, so the measurement register remains <code>00</code> (100 times).</li> <li><code>State</code> contains the full quantum state at the end of the very last iteration.   It maps quantum kets to complex amplitudes.   Here you can recognize the usual Bell pair state: <code>1/sqrt(2) ( |00&gt; + |11&gt; )</code>.</li> </ul> <p>Note</p> <p>The number of iterations does not affect the quantum state. For every iteration, the quantum state is reset to the ground state in the standard basis. Thus, the state returned as part of the simulation result is that of the last simulation iteration.</p> <p>If we now add measurements:</p> <pre><code>H q[0] \nCNOT q[0], q[1]\nb = measure q\n</code></pre> <p>The result will change to:</p> <pre><code>Shots requested: 100\nShots done: 100\nMeasurements: {'00': 49, '11': 51}\nState: {'00': (0.9999999999999998+0j)}\n</code></pre> <p>Due to the measurements, the state now collapses at the end of each iteration to either <code>|00&gt;</code> or <code>|11&gt;</code>. <code>Measurements</code> show that the state collapsed to <code>|00&gt;</code> in 49% cases and <code>|11&gt;</code> in 51%, so roughly a 50% chance for either outcome. <code>State</code> shows the quantum state at the end of the 100th iteration, in this case to <code>|00&gt;</code>.</p> <p>Note that its amplitude is not exactly 1 because of the approximation of real numbers done by floating point arithmetic inside the simulator, something to keep in mind when interpreting the results.</p> <p><code>Measurements</code> can here be interpreted as: in 49 iterations out of 100, the final measurement register was <code>00</code> and in the remaining 51 iterations it was <code>11</code>.</p>"}]}